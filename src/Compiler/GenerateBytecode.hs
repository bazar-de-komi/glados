-- | This module defines functions to transform an AST representation of a program into a list of bytecode instructions. 
-- It includes support for control structures, expressions, functions, and variable management.

{-# LANGUAGE LambdaCase #-}

module Compiler.GenerateBytecode
  ( generateInstructionsList,
  )
where

import Structure (AST(..), Instruction(..), BinaryOperator (..), BinaryComparator (..), Value(..), LabelState(..))

-- | Generates a unique label based on the label type (e.g., "loop" or "if") and the current state of label counters.
--
-- This function is used to create unique labels for control flow structures, such as loops or conditional branches.
-- The function updates the `LabelState` to reflect the incremented counter for the specified label type.
--
-- ==== Parameters
--
-- * `LabelState`: The current state of label counters. It contains:
--     - `loopCounter`: An integer representing the current counter for "loop" labels.
--     - `ifCounter`: An integer representing the current counter for "if" labels.
-- * `String`: A string indicating the type of label to generate. Accepted values are:
--     - `"loop"`: Generates a loop label (e.g., `"loop_0"`).
--     - `"if"`: Generates an if label (e.g., `"if_0"`).
--
-- ==== Logic
--
-- The function uses a `case` expression to determine which counter to increment based on the provided label type:
-- * If the label type is `"loop"`, the `loopCounter` is incremented.
-- * If the label type is `"if"`, the `ifCounter` is incremented.
-- * For any other label type, the function throws an error, as unsupported label types are not allowed.
--
-- ==== Returns
--
-- A tuple containing:
-- * `String`: The newly generated label, which combines the label type and the current counter value. 
--     - For example: `"loop_0"`, `"if_1"`.
-- * `LabelState`: The updated `LabelState` with the incremented counter for the specified label type.
--
-- ==== Example Usage
--
-- >>> generateLabel (LabelState 0 0) "loop"
-- ("loop_0", LabelState {loopCounter = 1, ifCounter = 0})
--
-- >>> generateLabel (LabelState 0 2) "if"
-- ("if_2", LabelState {loopCounter = 0, ifCounter = 3})
--
-- >>> generateLabel (LabelState 1 1) "unknown"
-- *** Exception: Unknown label type
generateLabel :: LabelState -> String -> (String, LabelState)
generateLabel (LabelState loop ifCount) labelType =
  case labelType of
    "loop" -> let newState = LabelState (loop + 1) ifCount
              in ("loop_" ++ show loop, newState)
    "if"   -> let newState = LabelState loop (ifCount + 1)
              in ("if_" ++ show ifCount, newState)
    _      -> error "Unknown label type"

-- | Recursively generates bytecode instructions from the given Abstract Syntax Tree (AST).
--
-- This function translates high-level AST nodes into a sequence of low-level bytecode instructions. 
-- The bytecode generation is tailored for a virtual machine or a compiler backend.
--
-- ==== Parameters
--
-- * `AST`: The input abstract syntax tree representing the program structure. The AST can include:
--     - Assignments
--     - Expressions (operations, literals, variables)
--     - Control structures (if statements, loops)
--     - Function definitions and calls
--     - Return statements
-- * `LabelState`: The current state of label counters used to generate unique labels for control flow structures 
--   (e.g., loops, if/else blocks).
--
-- ==== Returns
--
-- A tuple containing:
-- * `[Instruction]`: The list of generated bytecode instructions.
-- * `LabelState`: The updated label state after processing the given AST.
--
-- ==== Bytecode Instructions
--
-- The generated instructions include:
-- * `STORE_VAR`, `LOAD_VAR`: For variable storage and retrieval.
-- * `STORE_CONST`: For storing constant values (integers, floats, booleans, etc.).
-- * `OPERATOR`, `COMPARATOR`: For arithmetic and comparison operations.
-- * `JUMP`, `JUMP_IF_FALSE`, `LABEL`: For control flow.
-- * `LABEL_FUNC`, `LABEL_FUNC_END`, `CALL`, `RETURN`: For function handling.
--
-- ==== Examples
--
-- >>> generateBytecode (SList [SInt 1, SOperation "+", SInt 2]) (LabelState 0 0)
-- ([STORE_CONST (VInt 1), STORE_CONST (VInt 2), OPERATOR ADD], LabelState {loopCounter = 0, ifCounter = 0})
--
-- >>> generateBytecode (SIf (SBool True) (SInt 1) (SInt 2)) (LabelState 0 0)
-- ([STORE_CONST (VBool True), JUMP_IF_FALSE if_0, STORE_CONST (VInt 1), JUMP if_1, LABEL if_0, STORE_CONST (VInt 2), LABEL if_1], LabelState {loopCounter = 0, ifCounter = 2})
--
-- ==== Logic
--
-- The function matches AST nodes with specific patterns and generates corresponding bytecode:
generateBytecode :: AST -> LabelState -> ([Instruction], LabelState)

-- Assignment
generateBytecode (SList (SVariable var : SOperation "=" : expr)) state =
  let (exprInstructions, newState) = generateBytecode (SList expr) state
  in (exprInstructions ++ [STORE_VAR var], newState)

-- Operations
generateBytecode (SList [leftValue, SOperation op, rightValue]) state =
  let (leftInstructions, state1) = generateBytecode leftValue state
      (rightInstructions, state2) = generateBytecode rightValue state1
      opInstruction = case op of
        "+" -> [OPERATOR ADD]
        "-" -> [OPERATOR SUBTRACT]
        "*" -> [OPERATOR MULTIPLY]
        "/" -> [OPERATOR DIVIDE]
        "%" -> [OPERATOR MODULO]
        ">" -> [COMPARATOR COMPARE_GT]
        "<" -> [COMPARATOR COMPARE_LT]
        "==" -> [COMPARATOR COMPARE_EQ]
        "!=" -> [COMPARATOR COMPARE_NE]
        ">=" -> [COMPARATOR COMPARE_GE]
        "<=" -> [COMPARATOR COMPARE_LE]
        _   -> error ("Unsupported operation: " ++ op)
  in (leftInstructions ++ rightInstructions ++ opInstruction, state2)

-- Case for managing conditional expressions with a calculation
generateBytecode (SList [leftValue, SOperation op1, middleValue, SOperation op2, rightValue]) state =
  let (leftInstructions, state1) = generateBytecode leftValue state
      (middleInstructions, state2) = generateBytecode middleValue state1
      (rightInstructions, state3) = generateBytecode rightValue state2
      opCalculationsMap = 
        [ ("%", OPERATOR MODULO)
        , ("+", OPERATOR ADD)
        , ("*", OPERATOR MULTIPLY)
        , ("-", OPERATOR SUBTRACT)
        , ("/", OPERATOR DIVIDE)
        ]
      opComparisonsMap =
        [ (">", COMPARATOR COMPARE_GT)
        , ("<", COMPARATOR COMPARE_LT)
        , ("==", COMPARATOR COMPARE_EQ)
        , ("!=", COMPARATOR COMPARE_NE)
        , (">=", COMPARATOR COMPARE_GE)
        , ("<=", COMPARATOR COMPARE_LE)
        ]
      op1Instruction = case lookup op1 opCalculationsMap of
        Just opCalc -> [opCalc]
        Nothing -> case lookup op1 opComparisonsMap of
          Just opComp -> [opComp]
          Nothing -> error ("Unsupported operation: " ++ op1)
      op2Instruction = case lookup op2 opCalculationsMap of
        Just opCalc -> [opCalc]
        Nothing -> case lookup op2 opComparisonsMap of
          Just opComp -> [opComp]
          Nothing -> error ("Unsupported operation: " ++ op2)
      isOp1Calculation = op1 `elem` map fst opCalculationsMap
  in
    if isOp1Calculation
    then
      (leftInstructions ++ middleInstructions ++ op1Instruction ++ rightInstructions ++ op2Instruction, state3)
    else
      (middleInstructions ++ rightInstructions ++ op2Instruction ++ leftInstructions ++ op1Instruction, state3)

-- Visit AST
generateBytecode (SList ast) state = 
  let (instructions, newState) = foldl  (\(accInstr, accState) astElem ->
                                          let (instr, newState') = generateBytecode astElem accState
                                          in (accInstr ++ instr, newState')
                                        ) ([], state) ast
  in (instructions, newState)

-- Store variables
generateBytecode (SDefine name (SType _) value) state =
  let (valueInstructions, newState) = generateBytecode value state
  in (valueInstructions ++ [STORE_VAR name], newState)

-- Load variables
generateBytecode (SVariable var) state = ([LOAD_VAR var], state)

-- Store constants
generateBytecode (SInt n) state = ([STORE_CONST (VInt n)], state)
generateBytecode (SFloat f) state = ([STORE_CONST (VFloat f)], state)
generateBytecode (SBool b) state = ([STORE_CONST (VBool b)], state)
generateBytecode (SString s) state = ([STORE_CONST (VString s)], state)
generateBytecode (SChar c) state = ([STORE_CONST (VChar c)], state)

-- If
generateBytecode (SIf condition thenBranch elseBranch) state =
  let (elseLabel, state1) = generateLabel state "if"
      (endLabel, state2) = generateLabel state1 "if"
      (conditionInstructions, state3) = generateBytecode condition state2
      (thenInstructions, state4) = generateBytecode thenBranch state3
      (elseInstructions, state5) = generateBytecode elseBranch state4
  in (
    conditionInstructions ++
    [JUMP_IF_FALSE elseLabel] ++
    thenInstructions ++
    [JUMP endLabel, LABEL elseLabel] ++
    elseInstructions ++
    [LABEL endLabel],
    state5
  )

-- For loop
generateBytecode (SFor initExpr condExpr updateExpr body) state =
  let (initInstrs, initState) = generateBytecode initExpr state
      (loopCondLabel, loopState1) = generateLabel initState "loop"
      (loopEndLabel, loopState2) = generateLabel loopState1 "loop"
      (condInstrs, condState) = generateBytecode condExpr loopState2
      condJumpInstr = [JUMP_IF_FALSE loopEndLabel]
      (bodyInstrs, bodyState) = generateBytecode body condState
      (updateInstrs, finalState) = generateBytecode updateExpr bodyState
  in (
    initInstrs ++
    [LABEL loopCondLabel] ++
    condInstrs ++
    condJumpInstr ++
    bodyInstrs ++
    updateInstrs ++
    [JUMP loopCondLabel] ++
    [LABEL loopEndLabel], finalState
  )

-- While loop
generateBytecode (SLoop condExpr body) state =
  let (loopCondLabel, loopState1) = generateLabel state "loop"
      (loopEndLabel, loopState2) = generateLabel loopState1 "loop"
      (condInstrs, condState) = generateBytecode condExpr loopState2
      condJumpInstr = [JUMP_IF_FALSE loopEndLabel]
      (bodyInstrs, finalState) = generateBytecode body condState
  in (
    [LABEL loopCondLabel] ++
    condInstrs ++
    condJumpInstr ++
    bodyInstrs ++
    [JUMP loopCondLabel] ++
    [LABEL loopEndLabel], finalState
  )

-- SFunc
generateBytecode (SFunc name (SType _) params body) state =
  let funcLabel = name
      paramInstructions = case params of
        SList ps -> 
          let processParams [] = []
              processParams (SType _:SList vars:rest) =
                let varsInstructions =
                      concatMap (\case
                        SVariable param -> [STORE_VAR param]
                        _ -> error "Unsupported parameter format in vars"
                      ) vars
                in varsInstructions ++ processParams rest
              processParams _ = error "Invalid parameter format in function definition"
          in processParams ps
        _ -> error "Invalid parameter format in function definition"
      (bodyInstructions, newState) = generateBytecode body state
  in (
    [LABEL_FUNC funcLabel] ++
    paramInstructions ++
    bodyInstructions ++
    [LABEL_FUNC_END funcLabel],
    newState
  )

-- Return
generateBytecode (SReturn returnValue) state =
  let (returnInstructions, newState) = generateBytecode returnValue state
  in (
    returnInstructions ++
    [RETURN],
    newState
  )

-- Function Call
generateBytecode (SCall funcName (SList args)) state =
  let
    (argInstructions, newState) = foldl
      (\(accInstr, accState) arg ->
        let (argInstr, nextState) = generateBytecode arg accState
        in (argInstr ++ accInstr, nextState))
      ([], state)
      args
  in 
    (argInstructions ++ [CALL funcName], newState)

-- Unsupported cases
generateBytecode _ state = ([], state)

-- | Generates a complete list of bytecode instructions from the given Abstract Syntax Tree (AST).
--
-- This function acts as a high-level entry point for the bytecode generation process. It initializes the label state
-- and delegates the actual instruction generation to the `generateBytecode` function.
--
-- ==== Parameters
--
-- * `AST`: The input abstract syntax tree representing the program to compile into bytecode. The AST is expected to be
--   structured hierarchically, encapsulating program elements like assignments, expressions, control structures, and functions.
--
-- ==== Returns
--
-- * `[Instruction]`: A flat list of bytecode instructions representing the entire program. These instructions are ready
--   for execution by a virtual machine or further processing by a compiler backend.
--
-- ==== Examples
--
-- Example 1: A simple arithmetic expression.
-- >>> generateInstructionsList (SList [SInt 1, SOperation "+", SInt 2])
-- [STORE_CONST (VInt 1), STORE_CONST (VInt 2), OPERATOR ADD]
--
-- Example 2: A conditional statement with a boolean condition.
-- >>> generateInstructionsList (SIf (SBool True) (SInt 42) (SInt 0))
-- [STORE_CONST (VBool True), JUMP_IF_FALSE if_0, STORE_CONST (VInt 42), JUMP if_1, LABEL if_0, STORE_CONST (VInt 0), LABEL if_1]
--
-- ==== Logic
--
-- 1. The function initializes the label state to `LabelState 0 0`, ensuring all generated labels are unique and sequential.
-- 2. It calls the `generateBytecode` function with the input AST and the initial label state.
-- 3. The resulting list of instructions is extracted and returned.
--
-- ==== Usage
--
-- Use this function to generate a complete program's bytecode from its AST. For more detailed control over label
-- generation or partial AST processing, use `generateBytecode` directly.
--
-- ==== Limitations
--
-- This function assumes the AST is valid and well-formed. If the AST contains unsupported nodes or invalid structures,
-- errors may occur during the generation process.
generateInstructionsList :: AST -> [Instruction]
generateInstructionsList ast =
  let initialState = LabelState 0 0
      (instructions, _) = generateBytecode ast initialState
  in instructions
